# Who gets to do what in enterprise {#sec-auth}

One of the core responsibilities of an IT/Admin group is managing how
people are able to log into the different systems they need to do their
work. This is obviously a security issue -- making sure people are able
to access the systems they're supposed to -- and not others -- is a core
part of enterprise security.

It's also a logistical issue, and as enterprises get larger, managing
the flow of permissions into and out of systems can become a major
hassle.

A large organization might have dozens of people joining and leaving
each week. And they probably have dozens or hundreds of services.
There's just no way the IT/Admin team could reasonably manage services
one-by-one. And for users, having a different username and password for
each system is a nightmare. That is why almost all organizations with
more than a few users have centrally managed auth.

We'll start by talking about the issues that are likely to come up
around auth in a data science context. Then we'll get generally into
some background on how IT/Admins think about managing users and
permissions. Last, we'll talk about the technologies they use to
accomplish these goals so you can have an intelligent conversation with
them about it.

## How IT/Admins think about auth

Let's start with a broad introduction to what auth is and how IT/Admins
think about it in order to build up a mental model.

I find a real-world analogy to be helpful in understanding how auth
works. Think of all the different services your company's IT/Admin team
manages as rooms in a building. Email, database, data science workbench,
social media accounts, HR systems, and more. Each one is a room in the
building.

In order to comply with the principle of least privilege, these doors
are locked and guarded. Anyone who needs to access a particular door is
given access, but only to the doors they need.

In order to understand how an IT/Admin thinks about auth, put yourself
in the shoes of the person who has to manage security for the building.

When someone comes up to the door of a room, the guard for that door
will need to do two things. First, they'll need to know who that person
is. This process of identifying someone and validating that they are who
they say they are is called *authentication*.

Authentication is done by providing some sort of *credential* (or cred)
that verifies that the person actually is who they say they are. The
most common type of credential for computer systems is a username and
password combination.

Increasingly, organizations are moving towards other kinds of
credentials instead of or in addition to usernames and passwords,
including biometrics like fingerprints and facial identification,
multi-factor codes or a push notification on your phone, or ID cards of
some sort.

Once the guard knows who they are, they'll need to verify that the
person is allowed to enter the room. The process of checking what you're
allowed to do -- what *permissions* you have in IT-speak -- is called
*authorization*.

Together, the whole system of authenticating and authorizing people to
take actions inside a computer system are called *auth*.

Let's start by thinking about the case where auth isn't
centrally-managed. The guards for each room don't talk to each other, so
each guard issues a credential to the people who are allowed in and
maintains a list of who's allowed to enter. Maybe one has a keycard,
another has a passcode that changes weekly, and another just remembers
faces really well. This is obviously a huge pain for the user and also
isn't great for any organization that wants to set and meet central
security standards.

In the labs in section 3, this is how we configured our server. We
created a standalone server with standalone credentials. And while
that's secure enough on its own, it doesn't integrate with any central
IT/Admin capabilities.

This is common in small organizations without much central IT/Admin
expertise. Among enterprise organizations it is much rarer, mostly
because of the hassle for users and the risk to the system of having to
maintain so many separate credentials.

So let's start thinking about how we could make the management of this
system simpler and easier.

The first, and most obvious, thing would be to simplify things so all
the guards know to accept the same credentials. Maybe we just issue
everyone a keycard and passcode that they tell the guards. Then, the
guard can look at the person's keycard and radio in the passcode to
double check that it's valid.

But it's still not trivial to do authorization. The guards are still
going to have to maintain lists of who's allowed into their room. This
is called an Access Control List (ACL).[^4-3-auth-1]

[^4-3-auth-1]: Standard Linux permissions (POSIX permissons) that were
    discussed in [Chapter @sec-linux-admin] are basically a special case
    of ACLs. ACLs allow setting individual-level permissions for any
    number of users and groups, as opposed to the one owner, one group,
    and everyone else permissions set for POSIX.

    Linux distros now have support for ACLs on top of the standard POSIX
    permissions.

That'll make it way easier for the people using the system, and also
make it much somewhat more secure. Now we know all of the doors are
using a similar level of security and if someone loses their card or
gets it stolen, we just have to do one trade.

This is basically the situation that many companies have been in from
the mid 1990s onwards. An open protocol called Lightweight Directory
Access Protocol (LDAP -- pronounced ell-dap) and the Microsoft
implementation of LDAP called Active Directory (AD) allowed
organizations to maintain central lists of users and the groups to which
they belong.

They'd configure server-based services to query their LDAP/AD servers.
LDAP/AD would send back information on the user including their username
and groups and the service could use that information to authorize the
user.

From the perspective of securely and centrally managing services,
LDAP/AD is obviously a huge improvement over a world where each service
maintains completely independent auth systems.

But it clearly starts breaking down as the building starts getting
bigger.

In enterprises where there are dozens of people onboarding and
offboarding to dozens or hundreds of services each week, the virtual
equivalent of having to run around the building telling each guard to
add or subtract names from the list is a pain and is error prone.

You might think that the solution would be to just centrally manage the
allow-lists for all the rooms. That partially solves the problem, but
there are still a few remaining.

There's also a security issue here -- you have to trust all the guards.
What if the guard is secretly writing down all the passcodes somewhere
to use for themselves?

It's also annoying to have to maintain guards at each door. Wouldn't it
be nice to instead just verify the person's identity when they entered
the building and then have them let themselves into each door as they
need?

These issues with LDAP/AD led to the origination of Single-Sign On
(SSO).

SSO works like this. When you come in, you stop at the security booth
and exchange your credentials for a building access pass. This building
access pass has your name on it and a way to validate that its genuine.
Then you get rid of the guards and equip each door with a keycard lock.
Each door accepts only its own keycard.

Every time you want to go into a different door, you have to go back to
the security booth and show them your building access pass. They'll
check that it's still valid, check that you're allowed to enter the room
you want to go into, and issue you a keycard for the room. Then you can
go use that keycard and go about your business.

While this roundtrip to the security booth sounds a little complicated,
it actually drastically simplifies things, because the door you're
trying to get into doesn't ever need to know anything about you. It just
needs to know how to accept its own specific keycard. And while it might
seem slow for a human, it's nearly instantaneous for a computer.

There are a few different technologies that can be used to accomplish
SSO including SAML and OIDC/OAuth, which are open technologies, and
Kerberos, which is an older Windows-based way to do SSO.

These days, almost all enterprises are moving quickly towards
implementing SSO using either SAML or OAuth (or both).

If you -- for some reason -- actually have to configure your server with
a particular authentication scheme, there's more information in
[Appendix @sec-append-auth].

### Managing permissions

Now, let's talk a little bit about how the permissions themselves are
managed. You could start by just collecting up all the ACLs from each
room around the building and managing them out of the central booth.

This is a simple kind of permissions management that makes a lot of
intuitive sense.

But, as you can imagine, if your building has hundreds of rooms, that's
a lot of different rooms to keep individual lists for. Additionally, if
you have permissions changing a lot, having to change individual user
permissions is a pain.

Instead, you might want to create a role that has certain permissions
and then assign people to that role. For example, maybe there's the role
of `manager`, who has access to certain rooms. There might be another
role that's `executive` who has access to different rooms. Managing
permissions in this way is called *Role Based Access Control (RBAC)*.

![](images-auth/RBAC.png)

It has the advantage of allowing more flexibility in creating roles and
managing them relative to ACLs. You can also see how it'd be relatively
simple to hook up something like your centralized HR database to an RBAC
system by mapping actual users to a set of roles that is appropriate for
them.

But RBAC has its own drawbacks. RBAC can also result in role explosion
over time -- if people need specialized permissions, it's easier to
create tons and tons of special roles rather than figure out how to
harmonize them into a system.

It also can't accommodate certain kinds of highly specific permissions
scenarios. For example, what if you have a situation where room 4242
should only allow managers except from 9-12 on Tuesdays when it should
allow maintenance services? That's not something RBAC can accommodate.

If you have the need for even more granular permissions than RBAC can
provide, you can create rules based on the room, the person, and the
environment. This highly-flexible system is called *Attribute Based
Access Control (ABAC)*. The downside of ABAC is that it can be a real
pain to set up because it is so powerful.

TODO: ABAC diagram (mapping room 4242 to person/manager to environment)

The most well-known ABAC system is the AWS Identity and Access
Management (IAM) system. If you've ever been utterly befuddled by
applying permissions to resources in AWS, you can thank the complexity
of ABAC. That complexity is the tradeoff for the very high degree of
flexibility ABAC provides.

## Data Science Auth Concerns

The first and simplest concern that comes up for a new data science
workbench is that it needs to support whatever auth mechanism your
IT/Admin group has decided your organization is going to use. Hopefully
the second above has given you some context on what those various
mechanisms are.

These days, most data science tools you might want to use support all of
the standard SSO mechanisms -- though many of them reserve that
functionality for paid tiers.

### Data Access

The second concern that comes up is how to get access to data. For
example, if you're working on RStudio Server or JupyterHub, you almost
certainly need to get access to data in order to do your work. Depending
on how your organization works, that data may be on a network file
system, in some sort of cloud storage, or in a database.

If your data is on a network file system, you'll need to figure out a
way to get that network file system connected to your server. In most
cases, the way this works is that you'll create Linux users in your data
science environment that have permissions on the network file system.
Then, when you mount the file system, those users will have access to
the files it needs.

If you are using a cloud storage or database system, then you'll need to
re-authenticate from your data science environment into the data
environment. There are a few different ways you can do this.

The simplest way to access a data source is by providing a username and
password directly to that data source. This has the advantage of being
simple and easy to accomplish in code. But that's not an SSO-compliant
way of doing data access.

These days, most organizations have introduced SSO for the front doors
of their main systems, but SSO into a database is somewhat rarer, mostly
because relatively few databases have implemented such systems.

There are three main ways to accomplish SSO into a database.

The first and oldest is to use a Kerberos ticket, which is a relatively
old -- but highly secure -- way to do authentication. Kerberos is mainly
used in Windows-based environments, so it's mostly used when accessing a
Microsoft SQL Server.

If your organization uses Kerberos, you'll need to work with your
organization's IT/Admin group to get everything configured. They may be
able to configure it so that you never need to think about the Kerberos
ticket and accessing the database just works. For more details on how
Kerberos works and how to work with your organization's IT/Admin group,
see [the relevant section](#sec-kerberos) in [Appendix
@sec-append-auth].

The second way to accomplish SSO into a data source is to pass along an
*JSON Web Token (JWT, pronounced jot)*. A JWT is a
cryptographically-signed token that can be passed along to gain
authorization to the database. JWTs are the technology that underlies
OAuth/OIDC. For more information, see the [OAuth/OIDC
section](#sec-oauth) in [Appendix @sec-append-auth].

These days, the biggest limitation on the use of JWTs for database
access is whether your database accepts JWTs. You should talk to your
database provider or an IT/Admin who's very familiar to understand the
options your database provides.

The last way to access a data source seamlessly is via integration with
cloud IAM services. This will only work if you're trying to access a
cloud resource from another cloud resource. So you could allow access
from an EC2 instance to an S3 bucket, but not from your on-prem compute
cluster to an S3 bucket.

The patterns for doing this vary a lot by cloud and by the data science
tooling you're using. Configuring a cloud instance to "just know" who's
making a request is possible, but requires some savvy with managing
cloud services.

### Service Accounts

The last concern that comes up a lot is what entity is doing the access.
In workbench environments, it's common for humans to have credentials to
data sources and to login as themselves. However, when those resources
go to production, it's very common to introduce *service accounts*.

A service account is a non-human entity that has permissions of its own.
For example, maybe you've got a Shiny app that users use to visualize
data that's in a database. Very often, you don't want the app to have
the same permisions as the app's author, or to inherit the permissions
of the people viewing the app.

One important reason you might want this is that you want to manage the
permissions of the app itself even if the author were to leave the
company or change roles.

Instead, you want the app to be able to have permissions to do certain
database operations. In that case, you would create a service account to
give to the Shiny app that has exactly those permissions.

There's no particular magic to service accounts, but you'll need to
figure out how to make your app or report run as the right user and have
the correct service account credentials.

## Comprehension Questions

1.  What is the difference between authentication and authorization?
2.  What are some different ways to manage permissions? What are the
    advantages and drawbacks of each?
3.  What is some advantages of token-based auth? Why are most
    organizations adopting it? Are there any drawbacks?
4.  For each of the following, is it a username + password method or a
    token method? PAM, LDAP, Kerberos, SAML, ODIC/OAuth
