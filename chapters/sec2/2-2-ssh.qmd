# Connecting Securely with SSH {#sec-ssh}

Once your command line is configured, you can interact with your
computer in a new and more powerful way. SSH -- short for Secure
(Socket) Shell -- allows you to directly interact with the command line
on a server by just typing commands into the command line of your
computer.

In this chapter, you'll learn what SSH is and how it can be useful to
you accessing a server.

Using SSH looks deceptively simple. When you connect to a server, it'll
just look something like this:

``` {.bash filename="Terminal"}
> ssh alex@server.example.com
```

Once the connection is established, you'll be off to the races on your
server. Until you really grasp how SSH works, you'll have to google "how
to set up SSH" every single time you need to set up a new machine. So
let's spend a bit on how SSH works -- you'll still need to google the
commands, but you'll never be scared you're doing it wrong.

When you connect to another server via SSH, your computer reaches out
with a request to establish an SSH connection. The computer on the other
end -- the remote host -- will verify your identity and then open an
encrypted connection between your command line and its own.

SSH verifies identities with an *SSH key*. More precisely, SSH verifies
identities with an *SSH keypair*, as the key is split into two halves,
the *public key* and the *private key*.

I don't like the terms public key and private key, as it suggests a
symmetry that it misleading. If anyone had asked me, we should use the
terms SSH key for the private key and SSH lock for the public key. But
no one asked me.

In order to understand why, it's helpful to have a little background on
*public key cryptography* -- the mechanism behind SSH.

Public key cryptography verifies that a public and private key go
together via mathematical operations that are easy in one direction but
really hard to reverse. When a computer has a public key, it's really
easy for it to check whether a proffered private key is the right one,
but it would be really hard to derive the private key from the public
one.

For example, think of the number $91$. Now let's say you're given the
prime numbers $7$ and $13$. You can verify that $7 * 13 = 91$ in just a
few moments. But before you had $7$ and $13$, it would've taken you a
lot longer to find the prime factors of $91$.

In this example, the number $91$ would be the public key and the prime
numbers $7$ and $13$ together would be the private key. Now, this would
obviously be a very bad set of keys, but the idea is fundamentally the
same. In real public key cryptography, the mathematical operations are
substantially more complex and the numbers much, much
bigger.[^2-2-ssh-1]

[^2-2-ssh-1]: Prime numbers are just as important, though.

So while someone could try to reverse-engineer the private keys by brute
force, it'd take more time than we have left before the heat death of
the universe at current computing speeds.

That means that it's safe to share your public key anywhere you might
need to access using SSH like a remote server or git host, like GitHub.

But that doesn't make SSH foolproof.

On the other hand, your private key **must** be kept secret. While it's
basically impossible to fabricate a private key, it's totally possible
to steal one. The best practice is to never move it from the computer
where it was created, which is why you'll create one anywhere you're
SSH-ing from.

Don't share your private keys. Don't share your private keys. Seriously,
do not share your private keys.

## Practical SSH usage

Now that you've got an understanding of how SSH works, the steps should
be easy to remember.

1.  Create an SSH keypair on any machine you'll be SSH-ing from.
2.  Put the public key anywhere you'll be SSH-ing to.
3.  Use the `ssh` command to make the connection work.

### Step 1: Create Keypair

You'll create a keypair on any server you're SSH-ing **from**. Remember,
you should never move your private key. If you think the answer to a
problem you're having is to move your private key, think again. You
should create a new private key wherever you want to move it to.

To create an SSH keypair, you should just follow a tutorial online.
There are many.

In most cases, you'll only create one private key on each machine. If
you follow standard instructions for creating a key, it will use the
default name, probably `id_ed25519`.[^2-2-ssh-2] If you're only creating
one key, I'd recommend sticking with the default name. The `ssh` command
will just use your keys if they have the default name.

[^2-2-ssh-2]: The pattern is `id_<encryption type>`. `ed25519` is the
    standard SSH key encryption type as of this writing.

Your organization may mandate you have a unique keypair for every
service you're reaching out to. There isn't a cryptographic reason for
this. It's mostly to make it easier to swap out the keypair later if you
need to.

### Step 2: Register the public keys

To register a public key on a server you control, you'll add the public
key to the end of the user's `.ssh/authorized_keys` file in their home
directory. You'll have to make sure the permissions on the
`authorized_keys` file are correct. More on that in [Chapter
@sec-linux-admin].

If you're registering with a service like GitHub.com, their tutorial on
registering SSH keys will show you the right spot in their interface.

### Step 3: Use SSH

To use SSH, you type `ssh <user>@<host>` in the command line and
everything should work fine.

::: callout-note
## For Windows users

For a long time, Windows didn't support SSH out of the box, so SSH-ing
from Windows required a separate utility called *PuTTY*. More recent
versions of Windows support using SSH directly in PowerShell or in
Windows Subsystem for Linux (WSL). You may have to enable SSH. Google to
find directions.
:::

If you have multiple SSH keys or didn't use the default flag, you can
specify a particular key with the `-i` flag.

If you're using SSH a lot, I'd recommend setting up an SSH config file
(google it to learn how). You can include users, hosts, and other
details so you could shorten and addresses in a config file so instead
of typing `ssh -i my-ssh-key alex@server.example.com` to `ssh server` or
whatever you want.

Many people also like using *tmux* with SSH. tmux is a terminal
multiplexer, which allows you to manipulate terminal sessions from the
command line. SSH sessions block the terminal session they're using and
can break if they go inactive. tmux allows you to create sessions and
detach them so they won't break even if your computer goes to sleep. To
be honest, I found the learning curve too steep for me to bother with
tmux, but you may feel differently.

Lastly, if you ever run into trouble using SSH, it has one of my
favorite debugging modes.

If something's not working when you try to connect, just add a `-v` to
your command for verbose mode. If that's not enough information, add
another v for `-vv` and it gets more verbose.

Every v you add (up to 3) will make the output more verbose.

## Comprehension Questions

1.  Under what circumstances should you move or share your SSH private
    key?
2.  What is it about SSH public keys that makes them safe to share?

## Cheatsheet: `ssh` {#cheat-ssh}

``` bash
ssh <user>@<host>
```

| Flag | What it does                       | Notes                                 |
|------|------------------------------------|---------------------------------------|
| `-v` | Verbose, good for debugging        | Add more `v`s (up to 3) for more info |
| `-i` | Choose identity file (private key) | Pick which private key to use         |
