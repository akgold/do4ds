# Intro to Linux Administration {#sec-linux}

Most servers run on the Linux operating system (OS). So in order to
administer a server, you're going to have to learn a little about Linux.

In this chapter, you'll learn a little about what Linux is and then
you'll learn a lot about how to use bash to navigate and manipulate the
Linux OS.

## Linux is an operating system

A computer's OS defines how applications can interact with the
underlying hardware. OSes dictate how files are stored and accessed, how
applications are installed, how network connections work, how printers,
monitors, and mice can connect, and more. So when Microsoft Word gets
input from your keyboard or RStudio adds $1+1$, or Minecraft displays
blocks on your screen, it's the OS that defines the rules of the road.

Your laptop probably runs MacOS or Windows. Neither of them is Linux.
But Linux is dominant...basically everywhere else. Almost all of the
world's embedded computers -- in ATMs, cars and planes, TVs, smart
thermostats, and most other gadgets and gizmos -- Linux. If you have an
Android phone or a Chromebook -- that's Linux. Basically all of the
world's supercomputers use Linux.

Most importantly for our purposes, a majority of the world's servers
also run on Linux.[^3-3-linux-1]

[^3-3-linux-1]: The remainder are almost entirely Windows servers. There
    are a few other Unix-like systems that you might encounter, like
    Oracle Solaris. There is no MacOS server. There is a product called
    *Mac Server*, but it's just a program for managing Mac desktops and
    iOS devices.

    There are versions on Linux that run on desktop computers. Despite
    the best efforts of many hopeful nerds, desktop Linux is pretty much
    only used by professional computer people.

Relative to MacOS or Windows, there's something different about Linux.
Up aboveI kept saying "flavors of Linux" or "versions of Linux". That's
really different from Windows or MacOS. They just have one flavor and
your computer is either up-to-date or it's not.

Linux, on the other hand, comes in a wide variety of different flavors,
called *distributions*, *distros* for short. Linux distros differ widely
in both technical attributes as well as the licensing model.

The state of the Linux world makes more since if you understand a little
bit of history.

Before the early 1970s, the market for computer hardware and software
looked nothing like it does now. Computers of that era had extremely
tight linkages between hardware and software. For example, there was no
Microsoft Word you could use on a Dell machine or an HP machine or an
Apple machine.

Instead, every hardware company was also a software company. If Example
Corp's computer did text editing, it was because Example Corp had
written (or commissioned) text editing software specifically for their
machine. If Example Corp's machine could run a game, Example Corp had
written that game just for their computer.

Then, in the early 1970s, researchers funded by AT&T's Bell Labs
released *Unix* -- the first operating system.

Now, there was a piece of middleware that sat between the computer
hardware and the end-user software like text editing and games.

All of a suddent, the computer market started looking a lot more
familiar to 2020s eyes. Hardware manufacturers could build machines that
ran Unix and independent software companies could write applications
that ran on Unix. The degree of required coordination between hardware
and software went way down.

The one issue (for everyone but Bell Labs) was that they were paying
Bell Labs a lot of money because they owned the license for Unix. So in
the 1980s, programmers started writing Unix-like OSes. These so-called
*Unix clones* behaved just like Unix, but didn't include any actual Unix
code.[^3-3-linux-2]

[^3-3-linux-2]: Or at least they weren't supposed to. BSD is a Unix
    clone that has an interesting history of lawsuits over whether it
    illegally included Unix code. BSD is the best-known Unix clone other
    than Linux, mostly because MacOS is built on it.

In 1991, Linus Torvalds -- then a 21 year-old Finnish grad student --
released Linux, an open source Unix clone via a amusingly nonchalant
newsgroup posting, saying, "I'm doing a (free) operating system (just a
hobby, won't be big and professional like gnu)...Any suggestions are
welcome, but I won't promise I'll implement them :-)."[^3-3-linux-3]

[^3-3-linux-3]: More in the [History of Linux Wikipedia
    article](https://en.wikipedia.org/wiki/History_of_Linux).

    Pedants will scream that the original release of Linux was just the
    operating system *kernel*, not a full operating system like Unix.
    Duly noted, now go away.

Since then, Linux has seen tremendous adoption across the huge variety
of contexts I mentioned earlier.

So now we get back to different Linux flavors. As you might imagine,
your car's infotainment system has very different OS requirements from a
smartphone or the controller for your smart thermostat.

For server use, most organizations standardize on one of a handful of
distros. The most common open source distros are Ubuntu or CentOS. Red
Hat Enterprise Linux (RHEL) is the most common paid
distro.[^3-3-linux-4] Many organizations on AWS are using Amazon Linux,
which is independently maintained by Amazon but was originally a RHEL
derivative.[^3-3-linux-5]

[^3-3-linux-4]: RHEL and CentOS are related operating systems, but that
    relationship has changed a lot in the last few years. The details
    are somewhat complicated, but most people expect less adoption of
    CentOS in enterprise settings going forward.

[^3-3-linux-5]: As I'm writing this, Amazon Linux 2 is popular, but
    Amazon Linux 2023 (AL2023) was recently released. I'd expect AL2023
    or it's successor to be dominant by the time you read this.

Most individuals who have a choice in the matter prefer Ubuntu. It's
definitely my personal preference. It's a little simpler and easier to
configure than the others.

::: callout-note
### A note on Ubuntu Versioning

Most other distros just have numbered releases. Ubuntu versions are
numbered by the year and month they were released. Most people use the
Long Term Support (LTS) releases, which are released in April of even
numbered years.

Ubuntu versions have fun alliterative names, so you'll hear people refer
to releases by name or version. As of this writing, most Ubuntu machines
are running Bionic (20.04, Bionic Beaver) or Jammy (22.04, Jammy
Jellyfish).
:::

## Linux operates via bash commands

Administering a Linux server happens mostly from the command line using
the shell. Whether you're using bash or a bash alternative like zsh,
commands work exactly the same.

The philosophy behind bash and its derivatives says that you should be
able to accomplish anything you want with small programs invoked via a
*bash* *command*. Each command should do just one thing, and complicated
things should be accomplished by *composing* commands -- taking the
output from one as the input to the next.

Invoking a command is done by typing the command on the command line and
hitting `enter`.

Helpfully, most bash commands are an abbreviation of the word for what
the command does. Unhelpfully, the letters often seem somewhat random.
For example, the command to *list* the contents of a directory is `ls`,
which sorta makes sense. Over time, you'll get very comfortable with the
commands you use frequently.

Bash commands can be modified with *command arguments*, *flags*, and
*flag arguments*.

Command arguments provide details to the command. They come after the
command with a space in between. For example, if I want to run `ls` on
the directory `/home/alex`, I can run `ls /home/alex` on the command
line.

Some commands have default arguments. For example the default argument
for the `ls` command is the current directory. So if I'm in
`/home/alex`, I'd get the same thing from either `ls` or
`ls /home/alex`.

Options or flags modify how the command operates and come between the
command and arguments. Flags are denoted by having one or more dashes
before them. For example, `ls` allows the `-l` flag, which displays the
output as a list. So, `ls -l /home/alex` would get the files in
`/home/alex` as a list.

Some flags themselves have arguments. For example, the `-D` flag allows
specifying a format for how the datetime is displayed from `ls -l`. So
running `ls -l -D %Y-%m-%dT%H:%M:%S /home/alex` lists all the files in
`/home/alex` with the date-time of the last update formatted in
*ISO-8601* format, which is always the correct format for dates.

Bash commands are always formatted as
`<command> <flags + flag args> <command args>`. It's nice that this
structure is standard. It's not nice that the main argument is all the
way at the end because bash commands can get very long, and you don't
get the main argument till the very end.

To make commands more readable, it's often nice to break the command
over multiple lines and include one flag or argument per line. You can
tell bash you want it to continue a command after a line break by ending
the line with a space and a `\`.

For example, here's that long `ls` command more nicely formatted:

``` {.bash filename="Terminal"}
> ls -l \
  -D %Y-%m-%dT%H:%M:%S \
  /home/alex
```

There is also help available!

All of the flags and arguments for commands can be found in the
program's *man page* (short for manual). You can access the man page for
any command with `man <command>`. You can scroll the man page with arrow
keys and exit with `q`.

If you ever can't figure out how to quit, `ctrl + c` will quit from most
command line situations.

For the most part, you'll write commands directly on the command line.
It's also possible to write and run bash scripts, which usually end in
`.sh`. The advantage of writing bash scripts is that they can run
basically anywhere. The disadvantage is that bash is a truly ugly
programming language.

## Commands run on behalf of users

Whenever a program is running in Linux, it is running as a particular
user. Each user has a *username* to identify the user.

On any Unix-like system, the `whoami` command returns the username of
the active user. So when I run `whoami` on my MacBook, I get:

``` bash
❯ whoami                                                       
alexkgold
```

Usernames have to be unique on the system -- but they're not the true
identifier for a Linux user. A user is uniquely identified by their
*user id (`uid`)*, which maps to all the other user attributes like
username, password, home directory, groups, and more.

Each human who accesses a Linux server should have their own account. In
addition, many applications create *service account* users for
themselves and run as those users. For example, installing RStudio
Server will create a user with username `rstudio-server`. Then, when
RStudio Server goes to do something -- start an `R` session for example
-- it will do so as `rstudio-server`.

There's also one special user -- called the admin, root, sudo, or super
user. They get the ultra-cool `uid` 0.

::: callout-note
## A few details on UIDs

`uid`s are just numbers from 0 to over 2,000,000,000. `uid`s are
assigned by the system at the time the user is created and usually don't
need to be changed manually -- unless you need the same user to exist
across multiple machines. Then the `uid`s need to match.

If you are manually assigning `uid`s, you should choose a number above
10,000 and below 2,000,000. Everything below 10,000 is reserved for
predefined system accounts or application accounts and some applications
can't deal with `uid`s bigger than 2,000,000.
:::

Users belong to *groups*, which are collections of one or more users.
Each user has exactly one *primary* *group* and can be a member of
secondary groups.[^3-3-linux-6] By default, each user's primary group is
the same as their username.

[^3-3-linux-6]: Depending on your version of Linux, there may be a limit
    of 16 groups per user.

Like a user has a `uid` a group has a `gid`. User `gid`s start at 100.

You can see a user's username, `uid`, groups, and `gid` with the `id`
command. On my MacBook, I'm a member of a number of different groups,
with the primary group `staff`.

``` bash
 ❯ id                                                                
uid=501(alexkgold) gid=20(staff) groups=20(staff),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),701(com.apple.sharepoint.group.1),33(_appstore),100(_lpoperator),204(_developer),250(_analyticsusers),395(com.apple.access_ftp),398(com.apple.access_screensharing),400(com.apple.access_remote_ae)
```

If you ever need to add users to a server, the easiest way is with the
`useradd` command. Once you have a user, you may need to change the
password, which you can do at any time with the `passwd` command. Both
`useradd` and `passwd` start interactive prompts, so you don't need to
do much more than run those commands.

If you ever need to alter a user -- the most common task being to add a
user to a group, you would use the `usermod` command with the `-aG`
flag.

## The Linux Filesystem is a tree

Regardless of which Linux distro you're running, understanding where to
find things on your system is crucial.

All of the information available to a computer is indexed by its
*filesystem*. The filesystem is made up of *directories* or *folders*,
which are containers for other directories and for files.

On your laptop, you're probably used to browsing the filesystem with
your mouse. On your phone, the filesystem is completely obscured by
apps, but it's there.

Using Linux on a server, the only way to traverse the filesystem is with
written commands. Having a good mental model for what the filesystem
looks like is, therefore, really important.

On Linux, the entire filesystem is a tree (or perhaps an upside-down
tree). Every directory is contained in by a *parent directory*, and may
contain one or more *children* or *sub-directories*. The *root
directory, `/`* is the base of the tree and is its own parent. A `/` in
between two directories means that it's a sub-directory.

![](../sec2/images/directories.png){fig-alt="A tree of directories. / is the root, /home is a sub directory, /home/alex is a sub-sub-directory, and /etc is another sub-directory."
width="450"}

Every directory is a sub-directory of `/` or a sub-directory of a
sub-directory of `/` or...you get the picture. So the `/home/alex` *file
path* defines a particular location, which is the `alex` sub-directory
of `/home`, which is a sub-directory of the root directory, `/`.

The location of a particular file or folder is called the *file path*.

::: callout-note
## Linux filesystems in comparison

If you have a Mac, the Linux filesystem will be pretty familiar. That's
because MacOS is based on an operating system called BSD that, like
Linux, is a Unix clone. Like a Linux filesystem, your Mac has a single
root with other drives are mounted in -- though the graphical file
interface works pretty hard to obscure this fact.

If you're familiar with Windows, the Linux filesystem may seem a little
strange.

In Linux, each computer has exactly one filesystem, which is based at
the root, `/`. Network shares or other types of volumes can be mounted
somewhere on the filesystem, often below `/mnt`, but the fact that
they're on separate drives is obscured from the user.

In contrast, each physical or logical disk has its own filesystem with
its own root in Windows. You're probably familiar with `C:` as your main
filesystem. Your machine may also have a `D:` drive. If you've got
network share drives, they're likely at `M:` or `N:` or `P:`.

One other difference is that Windows uses `\` to separate file path
elements rather than `/`. This used to be a big deal, but newer versions
of Windows accept file paths using `/`.
:::

The Linux root contains a number of directories that are used for
certain things. Here are some of the ones you'll use most frequently:

-   `/home` - user home directories.

-   `/bin`, `/opt`, `/usr/local/`, `/usr/bin`- places you're most likely
    to install software.

-   `/etc` - configuration files for applications.

-   `/var` - variable data, most commonly log files.

These distinctions aren't super strict, and the guide for whatever
you're trying to do will tell you where to put important things. But
it's worth realizing that you might have an application that's installed
in `/opt`, is configured in `/etc`, and writes logs to `/var`.

## Files and directories live on paths

File paths can be *absolute* -- specified relative to the root -- so
they operate the same irrespective of the current working directory.
Absolute file paths are easy to recognize because they always start with
`/`.

When you want a command to run the same irrespective of where it's run
from, it's best to use an absolute path.

Whenever a command runs, it runs at a particular path in the filesystem,
called the *working directory*. You can get the absolute path to your
working directory with the `pwd` command, which is an abbreviation for
*print working directory*.

Sometimes it's convenient to use a *relative* file path, which starts at
the current working directory, denoted by `.`. So, for example, if I
want to access the `data` subdirectory of the working directory, that
would be available at `./data`.

For data science purposes, it's often very useful to create your entire
project as one directory and then reference files within the directory
using relative paths. Then your code will find the right file
irrespective of where it moves on your or someone else's machine.

The working directory's parent is at `..`. So, for example, you could
see everything in the parent directory of your current working directory
with `ls ..` or its parent with `ls ../..`. The users's home directory
is at `~`.

Along with being able to inspect directories, it's useful to be able to
change your working directory with the `cd` command, short for *change
directory*. You can use either absolute or relative file paths with
`cd`. So if you were in `/home/alex` and wanted to navigate to `/home`,
either `cd ..` or `cd /home` would work.

Some files or directories are *hidden* so they don't appear in a normal
`ls`. You know a file or directory is hidden because its name starts
with `.`. Hidden files are usually configuration files that you aren't
manipulating in normal usage. These aren't secret or protected in any
way, they're just skipped by `ls` for convenience.

You've already seen a couple of hidden files in this book -- your GitHub
Action was configured in the `.github` directory and your Prezto
configuration was done in the `.zpreztorc` file. You might also be
familiar with `.gitignore`, `.Rprofile`, and `.Renviron`. If you want to
display hidden files in a directory, you can use the `-a` flag (for all)
with `ls`.

## Permissions dictate what users can do

Every object in Linux is just a file. Every log -- file. Every picture
-- file. Every program -- file. Every system setting -- file.

Determining whether a user can take a particular action is really a
question of whether they have the right permissions on a particular
file.

For every file, there are three possible permissions: read, write, and
execute. Read means the user can see the contents of a file, write means
the user can save a changed version of a file, and execute means they
can run the file as a program.

Permissions are set at three levels -- the owner, the owning group, and
everyone else. So you can think of permissions in Linux as being
assigned in a 3x3 grid.

::: callout-note
There are more complex ways to manage Linux permissions. For example,
you might hear about Access Control Lists (ACLs). That's beyond the
scope of this book.

There is more information on different ways organizations manage users
and what they're allowed to do in [Chapter @sec-auth], which is all
about auth.
:::

For example, here's a set of permissions that you might have for a
program if you wanted anyone to be able to run it, group members to
inspect it, and only the owner to change it.

![](./images/perms-ex.png){fig-alt="A 3x3 grid read, write, execute, on one side and owner, owning group, and everyone else at the top. Green checks in all of the execute, write for the owner, and read for owner and owning group. Red xs everywhere else."
width="400"}

Directories also have permissions -- read allows the user see what's in
the directory, write allows the user to alter what's in the directory,
and execute allows the user to enter the directory. File permissions and
directory permissions don't have to match. For example, a user could
have read permissions on a directory, so they could see the names of the
files, but not actually have read permissions on any of the files, so
they can't look at the contents.

When you're working on the command line, you don't get a little grid of
permissions. Instead they're expressed in one of two ways. The first is
the string representation, which is a 10-character string.

The first character indicates the type of file: most often `-` for
normal or `d` for a directory.

The next nine characters are indicators for the three permissions for
the user, the group, and everyone else. There will be an `r` for read, a
`w` for write, and an `x` for execute or `-` to indicate that they don't
have the permission.

For example, here's the output of running `ls -l` on a python project I
have. Itshows the contents of a directory along with the permissions.

``` bash
❯ ls -l                                                           
-rw-r--r--  1 alexkgold  staff     28 Oct 30 11:05 config.py
-rw-r--r--  1 alexkgold  staff   2330 May  8  2017 credentials.json
-rw-r--r--  1 alexkgold  staff   1083 May  8  2017 main.py
drwxr-xr-x 33 alexkgold  staff   1056 May 24 13:08 tests
```

You can see that each line starts with the string representation of the
permissions. Additionally the owner and group are indicated by the two
words after the number.

In this directory, I, `alexkgold`, own all the files, and the group of
all the files is my group, `staff`. The `config.py` has permissions of
`rw-r--r--`, indicating that the user (`alexkgold`) can read and write
the file, and everyone else, including in the file's group `staff`, has
read-only permission.

In the course of administering a server, you will probably need to
change a file's permissions. You can do so using the `chmod` command.

For `chmod`, permissions are indicated as a three digit number, where
the first digit is the permission for the user, the second for the
group, and the third for everyone else. The way you get the right digit
is pretty clever -- you just sum up the permissions as follows: 4 for
read, 2 for write, and 1 for execute. You can check for yourself that
any set of permissions is uniquely identified by a number between 1 and
7.[^3-3-linux-7]

[^3-3-linux-7]: Clever eyes may realize that this is just the base-10
    representation of a three-digit binary number.

So to implement the permissions in the graphic above, you'd want the
permission set `751` to give the user full permissions (4 + 2 + 1), read
and execute (4 + 1) to the group, and execute only (1) to everyone else.

::: callout-note
If you spend any time administering a Linux server, you almost certainly
will at some point find yourself running into a problem and applying
`chmod 777` out of frustration to rule out a permissions issue.

I can't in good faith tell you not to do this -- we've all been there.
But if it's something important, be sure you change it back once you're
finished figuring out what's going on.
:::

In some cases you might actually want to change the owner or group of a
file. You can change users and groups with either names or ids. You can
do so using the `chown` command. Changing users just uses the username
and changing groups get prefixed with a colon.

In some cases, you might not be the correct user to take a particular
action. If you want to change the user you are, you can use the `su`
command to switch users. You'll be prompted for a password to make sure
you're allowed.

Every system has an admin user, who has full permissions on every file.
Additionally, there are some actions that are reserved only for the root
user, denoted because they're owned by root and only root has the power
to read, write, or edit.

When you need to do root-only things, you usually don't want to `su` to
be the root user. It's too powerful. Plus if you have user-level
configuration, it all gets left behind.

Instead, individual users can be granted the power to temporarily assume
root privlidges without changing to be the root user. This is
accomplished by making them members of the admin group. If a user is a
member of the admin group, they can prefix commands with `sudo` to run
those commands with root privilidges.

The name of the admin group varies by distro. In Ubuntu, the group is
called `sudo`.

## Manipulating files and directories

You'll often need to manipulate files and directories. Here's how.

You can copy a file or directory from one place to another using the
`cp` command. `cp` leaves behind the old file or directory and adds the
new one at the specified location. You can use the `-r` flag to
recursively copy everything in a directory.

You can move a file with the `mv` command, which does not leave the old
file behind.

If you want to remove a file entirely, you can use the `rm` command.
There is also a version to remove a directory, `rmdir`.

::: callout-warning
Be very careful with the `rm` command.

Unlike on your desktop there's no recycle bin! Things that are deleted
are instantly deleted forever.
:::

If you want to make a directory, `mkdir` makes a directory. `mkdir` gets
mad if it's not creating the whole file path, so the `-p` flag can be
handy to create only the parts of the path that don't exist.

Sometimes it's useful to operate on every file inside a directory. You
can get every file that matches a pattern with the wildcard, `*`. You
can also do partial matching with the wildcard to get all the files that
match part of a pattern.

For example, let's say I have a `/data` directory and I want to put a
copy of only the `.csv` files inside into a new `data-copy`
sub-directory. I could do the following:

```         
> mkdir -p /data/data-copy
> cp /data/*.csv /data/data-copy
```

### Moving things to and from the server

It's very common to have a file on your server you want to move to your
desktop or vice versa.

If you're moving multiple files, it's easier to combine them into a
single object and move that.

The `tar` command turns a set of files or whole directory into a single
archive file, usually with the file suffix `.tar.gz`. Creating an
archive also does some compression. The amount depends on the content.

In my opinion, `tar` is a rare failure of bash to provide standalone
commands for anything you need to do. `tar` is used to both create and
unpack (extract) archive files. Telling it which one requires the use of
several flags. You'll basically never use `tar` without a bunch of flags
and the incantation is hard to remember. I google it every time I use
it. The flags you'll use most often are in the cheatsheet below.

Once you've created an archive file, you can move it to or from a server
with the `scp` command. `scp` -- short for secure copy -- is basically
`cp`, but with an SSH connection in the middle.[^3-3-linux-8]

[^3-3-linux-8]: It's worth noting that `scp` is now considered "insecure
    and outdated". The ways it is insecure are rather obscure and not
    terribly relevant for most people. But if you're moving a lot of
    data, you may want something faster. If so, I'd recommend more
    modern options like `sftp` and `rsync`. I probably wouldn't bother
    if you're only occasionally `scp`-ing small files to or from your
    server.

Since `scp` establishes an SSH connection, you need to make the request
to somewhere that is accepting SSH connections. Since your server is
probably accepting SSH connections and your laptop probably (hopefully)
is not. That means that whether you're copying something to or from a
server, you'll run `scp` from a regular terminal on your laptop, not one
that's already SSH-ed into your server.

Regular `ssh` options work with `scp`, like `-i` and `-v`.

## Server admin = text file author

On a server, a huge fraction of what you'll be doing is reading and
writing configuration and log files from the server, so being
comfortable with the commands to do so is essential.

There are a few different commands I frequently use for reading files:

-   `cat` is the basic command to print a file, starting at the
    beginning.

-   `less` prints a file, starting at the beginning, but only a few
    lines at a time.

-   `head` prints only the first few lines and exits. It is especially
    useful to peer at the beginning of a large file, like a `csv` file
    -- so you can quickly preview the column heads and the first few
    values.

-   `tail` prints a file going up from the end. This is especially
    useful for log files, as the newest logs are appended to the end of
    a file. This is such a common practice that "tailing a log file" is
    a common phrase.

    -   Sometimes, you'll want to use the `-f` flag (for *follow*) to
        tail a file with a live view as it updates.

Sometimes you want to search around inside a text file. You're probably
familiar with the power of *regular expressions (regex)* to search for
specific character sequences in text strings. The Linux command `grep`
is the main regex command.

In addition to searching in text files, `grep` is often useful in
combination with other commands. For example, it's often useful to put
the output of `ls` into `grep` to search for a particular file in a big
directory.

The Linux *pipe operator*, `|`, takes the output of the previous command
and sends it into the next one. So if I was searching for a file whose
name contained the word `data`, that might look something like
`ls ~/projects/my-project | grep data`.

::: callout-note
## Ceci n'est pas une pipe?

The pipe should feel extremely familiar to R users.

The pipe from the `{magrittr}` package, `%>%`, was introduced in 2013,
and is a popular part of the `{tidyverse}`.[^3-3-linux-9] The
`{magrittr}` pipe was inspired by both the Unix (Linux) pipe and the
pipe operator in the `F#` programming language.

Due to its popularity, the pipe `|>` was formally added to the base R
language in R 4.1 in 2021.
:::

[^3-3-linux-9]: The title of this callout box is also the tagline for
    the `{magrittr}` package.

Along with the pipe, there are a few other operators you can use to
write into files without opening them.

When you have existing text you want to add to a file, you can use the
`>` command, which takes the output of a command on the left and writes
it as a new file. If the file you specify already exists, it will be
overwritten. If you want to append the new text, rather than overwrite,
`>>` appends to the end of the file.

A common reason you might want to do this is to add something to the end
of your `.gitignore`. For example, if you want to add your `.Rprofile`
file to your `.gitignore`, you could do that with
`echo .Rprofile >> .gitignore`. Note that `echo` is a command that just
repeats the input as a character string. Otherwise `.Rprofile` would be
treated as a command.

There are times when you want to make files or directories with nothing
in them. The `touch` command makes a blank file at the specified file
path. If you `touch` a preexisting file, it updates the time the file
was last updated without actually making any changes.

### vim and nano are Linux text editors

Sometimes, you'll need to actually open files to work with them in a
*text editor*.

There are two command line text editors you'll probably encounter:
`nano` and `vi`/`vim`.[^3-3-linux-10] While they're both powerful text
editing tools, they can also be intimidating if you've never used them
before.

[^3-3-linux-10]: `vi` is the original fullscreen text editor for Linux.
    `vim` is its successor (`vim` stands for `vi` improved). I'm not
    going to worry about the distinction.

You can open a file in either by typing `nano <filename>` or
`vi <filename>`.

At this point many newbie command line users find themselves completely
stuck, unable to do anything -- even just exit and try again. But don't
worry, there's a way out of this labyrinth!

If you opened `nano`, there will be some helpful-looking prompts at the
bottom. You'll see that once you're ready to go, you can exit with `^x`.
But you'll find yourself stymied when you try to exit with the caret
character, `^`, and an `x`.

On Windows, `^` is short for `Ctrl` and on Mac it's for Command (`⌘`),
so `Ctrl + x` or `⌘ + x` will exit.

Where `nano` gives you helpful -- if obscure -- hints, a first
experience in `vim` is the stuff of command line nightmares. You'll type
words and they won't appear onscreen. Instead, you'll experience
dizzying jumps around the page and words and lines of text will
disappear without a trace.

This is happening because `vim` uses the letter keys not just to type,
but also to navigate the page and interact with `vim` itself. This is
because `vim` was created before keyboards uniformly had arrow keys.
These days, `vim` still operates this way because people are used to it
and because it minimizes how much your hands have to move on the
keyboard.

While I've never felt taxed from using the arrow keys, `vim` keybindings
are worth spending some time learning. `vim` includes some powerful
shortcuts for moving within and between lines and selecting and editing
text. Most IDEs you might use, including RStudio, JupyterLab, and VSCode
have vim modes. Learning some of the basics can make you way faster
editing code files, plus you'll feel really cool.

Here I'm only going to teach you how to make changes, save, and exit
without issue. You'll have to get fancier on your own.

When you enter `vim`, you're in the (poorly named) *normal mode*, which
is for navigation only. Pressing the `i` key activates *insert mode*,
which will feel normal for those of us used to arrow keys. You can type
and words will appear and you can navigate with the arrow keys.

Now that you've figured out how to exit normal mode, you may wish never
to return. But it's the only way to save files and exit `vim`. You can
do so with the `escape` key.

In order to do file operations, you type a colon, `:`, followed by the
shortcut for what you want to do, and `enter`. The two most common
commands you'll use are save (write) with `w` and quit with `q`. You can
combine these together, so you can save and quit in one command using
`:wq`.

Sometimes you may want to exit without saving. If you've made changes
and try to exit with `:q`, you'll find yourself in an endless loop of
warnings that your changes won't be saved. You can tell `vim` you mean
it with the exclamation mark, `!`, and exit using `:q!`.

## Comprehension Questions

1.  Draw a mental map that includes the following: terminal, shell,
    theme manager, operating system, my laptop
2.  What are the parts of a bash command?
3.  Where do commands run? How do you know where they're going to run or
    specify a relative path?
4.  What are 4 commands to read text files?
5.  How can you copy, move, or delete a file? What about to or from a
    server?
6.  How do you know if you've opened `nano` or `vim`? How would you exit
    in either case?
7.  Create a mind map of the following terms: Operating System, Windows,
    MacOS, Unix, Linux, Distro, Ubuntu
8.  What are the 3x3 options for Linux file permissions? How are they
    indicated in an `ls -l` command?

## Lab: Set up a user

When you use your server's `.pem` key, you login as the root user.
You're going to create users for any actual humans who access the
system, including yourself. In this lab, we'll create a regular user and
add an SSH key for them so you can directly log in from your personal
computer.

### Step 1: Create a non-root user

Let's create a user using the `adduser` command. This will walk us
through a set of prompts to create a new user with a home directory and
a password. Feel free to add any information you want -- or to leave it
blank -- when prompted.

I'm going to use the username `test-user`. If you want to be able to
copy/paste commands, I'd advise doing the same. If you were creating
users based on real humans, I'd advise using their names.

``` {.bash filename="Terminal"}
adduser test-user
```

We want this new user to be able to adopt root privileges so let's add
them to the `sudo` group with

``` {.bash filename="Terminal"}
usermod -aG sudo test-user
```

### Step 2: Add an SSH key for your new user

We're going to register an SSH key for our new user by adding the key we
created in the last lab to the server user's `authorized_users` file.

First, you need to get your public key to the server using scp.

For me, the command looks like this

``` {.bash filename="Terminal"}
scp -i ~/Documents/do4ds-lab/do4ds-lab-key.pem \ 
  ~/.ssh/id_ed25519.pub \
  ubuntu@$SERVER_ADDRESS:/home/ubuntu
```

Note that I'm still using the `.pem` key to SSH in, because I don't have
another key registered yet.

Now the public key is on the server, but it's in the `ubuntu` user's home
directory. You'll need to do the following: 
1. Create `.ssh/authorized_keys` in `test-user`'s home directory.
2. Copy the contents of the public key you uploaded into the `authorized_keys` file. 
3. Make sure the `.ssh` directory and `authorized_keys` files are owned by `test-user` with `700` permissions on `.ssh` and `600` on `authorized_keys`.

You could do this all as the admin user, but I'd recommend switching to being `test-user` at some point with the `su` command.

::: callout-tip
If you run into trouble assuming `sudo` with your new user, try exiting
SSH and coming back. Sometimes these changes aren't picked up until you
restart the shell.
:::

Once you've done all this, you should be able to log in from your
personal computer with `ssh test-user@$SERVER_ADDRESS`.

Now that we're all set up, you should store the `.pem` key somewhere safe
and never use it to log in again.

When you ever want to exit SSH and get back to your machine, you can
just type `exit`.
