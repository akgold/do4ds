# Administering a Linux Server

Now that you've got a Linux server and you're able to log in, it's time to get acquainted with your server, learn how to move around, and start getting some things done.

There are two big differences between your laptop and a Linux server that you'll have to get used to. The first is that servers generally do not have graphical user interfaces (GUIs) for doing administrative tasks. If you want to adjust the system settings on your laptop or navigate from directory to directory, you can click through a file tree or open up your preferences pane. For the most case, all interaction you're going to have with your server is going to be via the command line. It's easier than you might think if you've never done it before, but it'll take a little learning.

![](images-servers/desktop-vs-server.drawio.svg "Desktop vs Server")

The second difference is that the server we set up runs Linux -- as do the overwhelming majority of the world's servers. If you're interacting with the command line, the differences between Linux and other operating systems (especially MacOS) aren't huge, but there's a little learning involved.

In order to get started, this section is going to be around navigating in Linux and learning how to do some basic administrative tasks. There are entire books written about Linux System Administration. Pick up one of those if you're curious.

## A little about Linux

Every computer in the world runs on an operating system. The operating system defines the way that applications -- like Microsoft Word, RStudio, and Minecraft -- can interact with the underlying hardware. They define how files are stored and accessed, how applications are installed and can connect to networks, and more.

TODO: Image of hardware, operating system, applications

Back in the early days of computing, basically every computer manufacturer created its own operating system that was super-tightly linked to the hardware. These days, there are only a few operating systems that most systems use.

For desktop and laptop computers, there's Windows, MacOS, and Linux; Windows and Linux for servers, and Android (actually a flavor of Linux) and iOS for phones and tablets.[^2-3-linux-admin-1]

[^2-3-linux-admin-1]: There are no Mac servers. There is a product called *Mac Server*, but it's used to manage Mac desktops and iOS devices, not a real server.

    There are also a few other operating systems that you'll rarely encounter, like Oracle Solaris.

The 1960s were a wild time for operating systems. Basically every computer company invented their own operating system for their machines. In the early 1970s, AT&T labs released a proprietary operating system called Unix.

Unix espoused a philosophy of small system-level programs that could be chained together to do more complex things. It turned out that this philosophy made a lot of sense, and starting in the early 1980s, a variety of *Unix-like* operating systems were released. Unix-like operating systems were clones -- they behaved like Unix, but didn't actually include any code from Unix (because it was proprietary).

::: callout-note
This philosophy, called piping, should feel extremely familiar to you if you're an R user. The tidyverse pipe `%>%` and the base R pipe introduced in R 4.1 `|>` are both directly inspired by the Unix/Linux pipe `|`.
:::

Linux is the most successful of those clones, an open source Unix-like operating system released in 1991 by software engineer Linus Torvalds.[^2-3-linux-admin-2] Another of those clones was the predecessor to what is now MacOS.

[^2-3-linux-admin-2]: People who are pedantic about operating systems or the history of computing will scream that the original release of Linux was just the operating system *kernel*, not a full operating system like Unix. I've noted it here to satisfy pedants, but it doesn't matter much in practice.

A difference you've probably experienced before between Unix-like systems and Windows, which is not Unix-like is the type of slashes used in file paths. Unix-like systems use forward slashes `/`, while Windows uses back slashes `\`.

A huge majority of the world's servers run on Linux. There are meaningful Windows server deployments in some enterprises, but it's relatively small compared to the install base of Linux servers. Along with most of the world's servers, almost all of the world's embedded computers -- in ATMs, cars and planes, TVs, and most other gadgets and gizmos -- run on Linux. If you have an Android phone or a Chromebook -- that's Linux. Basically all of the world's supercomputers use Linux.

As you might imagine, the profusion of Linux in all different kinds of systems similarly necessitates different kinds of Linux. The Linux you're going to run on a server that's designed to be a data science workbench is going to be very different from the version of Linux running in your car or on your phone.

There are many different distributions (usually called "distros") of Linux, for desktop, server, and other applications.

There are a few main distros you're likely to run across on servers in your organization -- Ubuntu, Red Hat Enterprise Linux (RHEL), Amazon Linux 2, and SUSE ([pronunced soo-suh](https://www.youtube.com/watch?v=nLdexZlVkAY)).[^2-3-linux-admin-3]

[^2-3-linux-admin-3]: CentOS (short for Community ENTerprise Operating System) is an open source operating system maintained by Red Hat. Red Hat is changing the relationship between CentOS and RHEL and is discontinuing released of CentOS until 2024.

## A tiny intro to Linux administration

Being a competent Linux admin is a career unto itself. So we're not going to try to get you there in this chapter. Instead, the goal of this chapter is going to be to get you familiar with the basic tasks of interacting with a Linux server and the tools you need to at least get started working on one.

When you log into a Linux server, you'll be interacting exclusively via the command line, so all of the commands in this chapter are going to be terminal commands. If you haven't yet figured out how to open the terminal on your laptop and got it themed and customized so it's perfect, I'd advise going back to [Chapter 2-2 on the command line](#command-line).

It's also worth mentioning that if you're using a Mac, many of these same tools and techniques will work out of the box and may be useful on your laptop. If you're running Windows, you may have to look up the exact commands and syntax -- but the general idea will hold.

In just a second, we'll get into how to administer a Linux server, but let's first talk about what are the main tasks of Linux administration:

-   **Moving around** **and file operations** A lot of the things you'll do administering a server are just moving around, looking at different files, and interacting with them. We'll spend some time on how to move around on the command line and how to interact with files.

-   **Managing users** In general, if you're running a server, you're going to be managing a number of different users on the server. Creating users and groups and managing them -- specifically the things they're allowed to do is a huge part of server administration, and we'll go over what you'll need to do and how.

-   **Managing resources** As a server admin, especially in the cloud, you've got the ability to manage the resources -- CPU, RAM, and memory -- available to you. Keeping track of how much you've got of these things, how they're being used, and making sure everyone is playing nice together with the shared resources is an important task.

-   **Networking** Because your server is only valuable if you and others can connect to it, managing how your server can connect to the environment around it is an important part of Linux administration.

Below, I'm intentionally mixing up bash commands and Linux system commands because they're useful. If you know the difference and are pedantic enough to care, this list isn't for you anyway.

The first thing that's important to understand is that once you've SSH-ed into another server, your terminal is like a little window into that server. So everything that runs in the terminal is actually running on that other server and just bringing the results back to your eyes. But if you want to -- for example -- actually move a file from place to place, you'll need to do something else.

### Understanding the Linux file system

In the last chapter, you SSH-ed into your server using the `pem` key that was granted to you when you created the server. When you got there, you got dumped into the command line. So the first step is understanding where you are and how to go elsewhere.

The first thing to understand in Linux is that commands always happen *in a particular* *place* -- called the working directory -- and *as a particular user*. Depending on who you are and where you are, the commands you're allowed to run and what happens when you do so might be different. It's worth noting that this is also true on your laptop, but the experience of clicking on and using apps obfuscates the fact that this is happening under the hood.

When you land using the `pem` key, you've logged in as the root user and you're at the file path root.

At any time, you can get the path where you're sitting with the `pwd` command, which is an abbreviation for *print working directory*.

On a Linux server, you can think of the entire file system as a tree (for me an upside-down tree resonates more, since we generally talk about going "down" the tree to get to branches). The root of this tree is at `/`, and every file, folder, directory, and app is somewhere down the tree from `/`.

::: callout-note
If you're a Windows person, you might think this is analogous to `C:` -- it is, but only sorta.

You're right that the root of your drive is at `C:` and other things are descended from there.

Unlike in Linux, in Windows you can have multiple roots, one for each physical or logical disk you've got. That's why your machine may have a `D:` drive, or if you have network shares, those will often be on `M:` or `N:` or `P:`, each with its own sub-tree.

In Linux, *everything* is a subtree below `/`, and it has nothing to do with the drives that house each of them. If you do have extra drives mounted to your Linux server, `/mnt` (short for mount) is a popular place to put them.
:::

In addition to being the root of the file tree, `/` is used to separate directories and files, so for example `/opt/R` is the directory (or file) called R inside the `opt` directory, which is inside `/`.

Whenever you're locating a directory or file, you can do so using either *absolute* or *relative* file paths. An absolute file path is the location of a file relative to the file root, `/`, while a relative file path is the path relative to the spot where you are right now.

When you're writing out a file path, you can also explicitly access the working directory using `.`. In the last chapter, we talked about the `ls` command, which lists what's in the working directory. Now, you understand that `ls` just has a default argument of `.`, so `ls` and `ls .` do exactly the same thing.

So an absolute (sometime called fully-qualified) path always starts with `/` and might look something like `/home/alex/`. So regardless of what your working directory is, `ls /home/alex` will always show the contents of `/home/alex`.

A relative path starts from your working directory. So I can run `ls alex`, and that will look for a directory named `alex` on the next rung down the tree from where I am and list its contents, if it exists. So if I'm in `/home`, `ls alex` will return the same thing as `ls /home/alex`, but otherwise it will return something else.

If you ever want to explicitly indicate your working directory in a file path, you can do so with `.`, so `ls ./alex` is the same as `ls alex`.

Sometimes absolute file paths make more sense, and sometimes relative paths do. In general, absolute file paths make more sense when you want to access the exact same resource from multiple places, and relative file paths make more sense when you want to access the same resource that might exist in different places. Now that you understand generally where you are, let's talk about how to start interacting.

### Moving around and interacting

The first thing you'll need to do is to look around your working directory and other directories, using the `ls` command, which we've already discussed in some detail.

Once you've looked around, you'll have to move somewhere -- you can change your working directory with the `cd` command, short for change directory.

There are a few directories with special names, aside from the root `/`. Your current working directory is always at `.`, and the parent of your current directory is at `..`, so you can move to the parent of your current directory using `cd ..` and up two levels with `cd ../..`.

We'll get more into users below, but if your user has a home directory, that home directory is at `~`.

There will be times when you have to copy, move, or remove files -- each of these things can be accomplished with commands that are similarly abbreviated forms of the relevant words -- `cp`, `mv`, and `rm`.

::: callout-warning
Be very careful with the `rm` command.

Unlike on your desktop there's no recycle bin! Things that are deleted are instantly deleted forever.
:::

If you want to copy, move, or remove files, the `-r` flag for `recursive` is a handy one -- if you try to copy, move or remove a directory, you often mean to act on the entire subtree below that directory, which the `-r` flag indicates.

Similarly, sometimes you want to list everything in a directory. For example, you might want to copy the entire contents of a directory. In that case, the wildcard, `*`, returns everything in a directory. So `cp alex/* alex2` copies the full contents of `alex` into `alex2`.

There are times when you want to make files or directories with nothing in them -- the `touch` command makes a blank file at the specified file path, and `mkdir` makes a directory at the specified filepath. `mkdir` can be a little finicky about when paths exist and it will only make one level. So `mkdir my_dir` works, but `mkdir my_dir/my_sub_dir` does not. Using `mkdir -p`, it will use existing paths and make whichever parts of the path don't yet exist.

### Interacting with server configuration

On a Linux system, almost everything is either a text file or an executable. That means that configuration files and logs are just text files, and so you can interact with them all the same way.

A very common pattern in Linux administration is to read a log file to look for errors or clues, adjust a configuration setting as a result, and then restart a process.

## Miscellaneous Symbols

| Symbol | What it is                    | Helpful options | Example |
|--------|-------------------------------|-----------------|---------|
| `man`  | **man**ual                    |                 |         |
| `|`    | the pipe                      |                 |         |
| `echo` |                               |                 |         |
| `$`    | treat something as a variable |                 |         |

## Moving yourself and your files

<table>
<thead>
<tr class="header">
<th><p>C ommand</p></th>
<th><p>What it does</p></th>
<th><p>Helpful options</p></th>
<th><p>Example</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>/</code></p></td>
<td><p>system root</p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><code>.</code></p></td>
<td><p>current working directory</p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><code>pwd</code></p></td>
<td><p><strong>p</strong>rint <strong>w</strong>orking <strong>d</strong>irectory</p></td>
<td></td>
<td><p><code>$ pwd</code></p>
<p><code>/U sers/alex.gold/</code></p></td>
</tr>
<tr class="even">
<td><p><code>cd</code></p></td>
<td><p><strong>c</strong>hange <strong>d</strong>irectory</p></td>
<td></td>
<td><p><code>$ cd ~/Documents</code></p></td>
</tr>
<tr class="odd">
<td><p><code>ls</code></p></td>
<td><p><strong>l</strong>i<strong>s</strong>t</p></td>
<td><p><code>-l</code> - format as list</p>
<p><code>-a</code> - all include hidden files</p></td>
<td><p><code>$ ls .</code></p>
<p><code>$ ls -la</code></p></td>
</tr>
<tr class="even">
<td><p><code>rm</code></p></td>
<td><p><strong>r</strong>e<strong>m</strong>ove delete permanently!</p></td>
<td><p><code>-r</code> - recursively a directory and included files</p>
<p><code>-f</code> - force - dont ask for each file</p></td>
<td><p><code>$ rm old_doc</code></p>
<p><code>r m -rf old_docs/</code></p>
<p>BE VERY CAREFUL WITH <code>-rf</code></p></td>
</tr>
<tr class="odd">
<td><p><code>cp</code></p></td>
<td><p><strong>c</strong>o<strong>p</strong>y</p></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><code>mv</code></p></td>
<td><p><strong>m</strong>o<strong>v</strong>e</p></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><code>mkdir</code></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><code>touch</code></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><code>*</code></p></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

## A rough `vim` intro

## Checking out Files

Often useful in server contexts for reading log files.

<table>
<thead>
<tr class="header">
<th><p>Command</p></th>
<th><p>What it does</p></th>
<th><p>Notes + Helpful options</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>touch</code></p></td>
<td><p>Updates the timestamp on a file.</p></td>
<td><p>Creates a blank file if no file of that name exists.</p></td>
</tr>
<tr class="even">
<td><p><code>cat</code></p></td>
<td><p>Prints a file.</p></td>
<td></td>
</tr>
<tr class="odd">
<td><p><code>less</code></p></td>
<td><p>Prints a file, but just a little.</p></td>
<td><p>Can be very helpful to look at a few rows of csv.</p>
<p>Only reads what youre looking at, so can be <em>much</em> faster than <code>cat</code> for big files.</p></td>
</tr>
<tr class="even">
<td><p><code>tail</code></p></td>
<td><p>Look at the end of a file.</p></td>
<td><p>Log files usually are written so the newest part is <em>last</em>. So much so that tailing a log file is a synonym for looking at it.</p>
<p>If you want to get a live view of a log file that will update as more is written, use the <code>-f</code> flag (for <em>follow</em>).</p></td>
</tr>
<tr class="odd">
<td><p><code>grep</code></p></td>
<td><p>Search a file using regex.</p></td>
<td><p>Useful to search inside a file, but youve gotta write regex. I suggest testing expressions on regex101.com.</p>
<p>Often useful in combination with the pipe.</p></td>
</tr>
<tr class="even">
<td><p><code>tar</code></p></td>
<td><p>Compress or decompress a file/directory.</p></td>
<td><p>Annoyingly almost never used without flags.</p>
<p>Create usually done using</p>
<p><code>tar -czf &lt;archive name&gt; &lt;file(s) to tar&gt;</code></p>
<p>Extract usually done with</p>
<p><code>tar -xfv &lt;archive name&gt;</code></p></td>
</tr>
</tbody>
</table>

## Checking out Server Activity

Restarting processes?

| C ommand | What it does | Helpful options | Example |
|----------|--------------|-----------------|---------|
| `df`     |              | -h              |         |
| `top`    |              |                 |         |
| `ps`     |              |                 |         |
| `lsof`   |              |                 |         |

## Checking out Networking

| C ommand   | What it does | Helpful options | Example |
|------------|--------------|-----------------|---------|
| `ping`     |              |                 |         |
| `ne tstat` |              |                 |         |
| `curl`     |              |                 |         |

## User + Permissions Management

<table>
<thead>
<tr class="header">
<th><p>Command</p></th>
<th><p>What it does</p></th>
<th><p>Helpful options</p></th>
<th><p>Example</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p><code>~</code></p></td>
<td><p>your home directory</p></td>
<td></td>
<td><p><code>echo ~</code></p>
<p><code>/ home/alex.gold</code></p></td>
</tr>
<tr class="even">
<td><p><code>su</code></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><code>whoami</code></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><code>passwd</code></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td><p><code>useradd</code></p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p><code>chmod</code></p></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

## Lab: Setting up a user, configuring SSH, Installing R, Python, and More

# Accessing Servers via SSH {#ssh}

Now that you're set up and comfortable using the command line, let's spend some time exploring SSH.

SSH -- short for Secure (Socket) Shell -- is the standard way of accessing servers for the purpose of administering them using command line tools. By using SSH, you can have a terminal open on your laptop, but instead of interacting with your local machine, you'll be interacting with a remote server.

Whenever you're using SSH, the correct mental model in your head is that you're typing the command into your local terminal, but it's actually running off on the remote server. SSH is the technology that allows those commands and their results to go securely back and forth between the server and your terminal window.

In your day-to-day usage of SSH, the main thing you'll have to do is manage your SSH keys. SSH keys are gibberish strings of letters and numbers that allow your computer to verify that it's you to the server you want to access.

Here's how it works -- when you want to SSH into a server, you'll create an SSH keypair. This keypair has two components -- the *public key* and the *private key*.

You'll take the public key and put it on the server you're trying to access and you'll keep the private key securely on your laptop. Then, when you go to access the server, you'll use the command line to open an SSH session and the server will check that the public key it has matches the private key your laptop is offering.

If it matches, you get an SSH session!

#### How SSH works

At first blush, the way SSH works seems nonsensical. I can just take my public key and just kinda chuck it out into the world and then it's all ok?!?

Like most cryptography, public key encryption relies on mathematical operations that are easy in one direction, but hard in the other.

For example, it's computationally trivial to multiply two large prime numbers and check if they equal some other number, but it's very computationally expensive to start with a big number and find the largest prime factors of that number.

In an oversimplified (but useful) mental model, you can think about the public key as just being a large number, and the private key being the two primes. While it seems like it might still be insecure, SSH keys are *very* big numbers. Modern encryption standards mean that it's basically impossible to break a public SSH key.

However, it is totally possible to compromise the security of an SSH connection by being sloppy with your private keys. So while SSH is cyptographically super secure, the whole system is only as secure as you. Don't share your SSH private keys.

## Lab: Accessing the Terminal and Setting up SSH

Hopefully you're all set up with your terminal theme, feeling great about turning into a hacker.

To start, open your terminal program.

You should be confronted by the command prompt where you'll start typing.

We're going to start by creating a new SSH key and putting it on the server we set up.

*NOTE - should we do this after creating a user?*

Use scp

### Create an SSH key

**For Mac**

From the terminal on your machine, you'll run the `ssh-keygen` utility to create a public/private key pair.

-   The terminal
-   3 step process
    1.  generate public/private keys `ssh-keygen`
    2.  place keys in appropriate place
    3.  use ssh to do work
-   Permissions on key

## Getting Comfortable in your own setup

-   Using ssh-config

## Advanced SSH Tips + Tricks

-   SSH Tunneling/Port Forwarding
-   -vvvv, -i, -p \[Diagram: Port Forwarding\]

TODO: talk about command line programs + flags

Try standing up a new server and installing R and RStudio Server Open Source, or Python and JupyterHub.

-   Hint 1: Remember that your instance only allows traffic to SSH in on port `22` by default. You access RStudio on port `8787` by default and JupyterHub on port `8000`. You control what ports are open via the Security Group.

-   Hint 2: You'll need to create a user on the server. The `adduser` command is your friend.
