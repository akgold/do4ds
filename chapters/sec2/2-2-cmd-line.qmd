# Customizing the command line {#sec-cmd-line}

When you want to open a file on your computer or adjust settings, you
just click through a file tree or open your preferences pane.

Servers generally have no *graphical user interfaces (GUIs)* at all. On
a server, interaction is via the command line -- an all-text interface
where you type commands.

There's somewhat circular logic here. There's not a ton of demand for
graphical admin tools because most admins can use the command line and
most admins learn to use the command line because there aren't good
graphical alternatives. Either way, if you want to do server
administration you have to get comfortable on the command line.

::: callout-note
In some organizations, server admin tasks are done via a graphical tool.
This is a red flag. It means that the organization is either trying to
find admins who haven't bothered to learn to use the command line or are
using an intermediary tool to limit what admins can do.

Either way, it's going to be harder to get things done.
:::

In fact, even if you're just a data scientist, it's worth learning your
way around the command line. There are a variety of tasks that are
quicker and easier that way. Most people who learn the command line end
up using it a lot on their personal computers.

In this chapter, we're going to get you started with the command line on
your computer. We're going to dive into two particular topics --
customizing the command line so it looks and behaves the way you want
and using SSH to securely log in to administer your server.

## Getting the command line you want

Pretty soon after getting started on the command line, you'll realize
that some customization is in order. Maybe the colors aren't quite
right, or you want shortcuts for commands you type a lot, or you want
more information in the default display.

Some people might argue that expending energy customizing your command
line isn't the best use of your time.

Those people are no fun.

Having a command line that behaves exactly as you like will speed up
your work and make you feel like a hacker.

But as you get started, you'll soon find yourself neck deep in Stack
Overflow posts on how to customize your `.bashrc`. Or wait, is it the
`.zshrc`? Or...

The reason customizing your command line is somewhat confusing is that
the command line you interact with is actually two or three programs
that sit on top of each other. You can mix-and-match options for each of
them and configure them in a variety of ways.

::: callout-note
### Notes on operating systems

I've been using the command line in MacOS for many years, so I have
strong opinions to share in this chapter.

I haven't used a Windows machine in many years. I've collected some
recommendations, but I can't personally vouch for them the same way.

I don't include Linux recommendations because people who use Linux on
their desktop have already gone deep down the customization rabbit hole
and don't need my help wasting their time.
:::

## The terminal

The terminal is the GUI where you'll type in commands. The terminal
program you use will dictate the colors and themes available for the
window, how tabs and panes work, and the keyboard shortcuts you'll use
to manage them.

Some programs you might use, like RStudio or VSCode have terminals built
into them. If you do basically all your terminal work from one of these
environments, you may not need another. But it can be nice to have a
standalone terminal program you like.

::: panel-tabset
### MacOS

I'd recommend against using the built-in terminal app (called
*Terminal*). It's fine, but there are better options.

My personal favorite is the free [*iTerm2*](https://iterm2.com/), which
adds a bunch of niceties like better theming and multiple tabs.

### Windows

The built-in terminal is the favorite of many users. There are a variety
of alternatives you can try, but feel free to stick with the default.
:::

## The shell

The shell is the program that takes the commands you're typing and runs
them. It's what matches the words you type to actual commands or
programs on your system. Depending on which shell you choose, you'll get
different options for plugins and themes.

The shell runs anywhere you've got a running operating system. So your
computer has one shell and your server would have a different one. Even
a Docker Container has a shell available. That means that if you do a
lot of work on a server, you may need to configure your shell twice --
once locally and once on the server.

::: panel-tabset
### MacOS

The default shell for MacOS (and Linux) is called *bash*. I'd advise you
to switch it out for *zsh*, which is the most popular *bash
alternative*.[^2-2-cmd-line-1]

Relative to bash, zsh has a few advantages out of the box, like better
auto-completion. It also has a huge ecosystem of themes to enhance
visual appeal and functionality, and plugins that let your command line
do everything from displaying your git status to controlling your
Spotify playlist.

All so-called bash alternatives are just bash with some extra bells and
whistles, so they're very similar. So if you log into a server that's
running bash rather than zsh, you might be annoyed that some of your
shortcuts don't work, but you won't be lost.

I'd recommend looking up instructions for how to install zsh using
*Homebrew*, which you should also install if you haven't already.

### Windows

Windows comes with two shells built in, the *Command Shell* (`cmd`) and
the *PowerShell*.

The Command Shell is older and has been superseded by PowerShell. If
you're just getting started, you absolutely should just work with
PowerShell. If you've been using Command Shell on a Windows machine for
a long time, most Command Shell commands work in PowerShell, so it may
be worth switching over.
:::

[^2-2-cmd-line-1]: zsh is pronounced by just speaking the letters aloud,
    *zee-ess-aitch*. Some people might disagree and say it's *zeesh*,
    but they're not writing this book, are they?

## Configuration management

Now that you've got your shell and terminal installed, let's get it
customized just for you. It is possible to directly customize both zsh
and PowerShell. In most cases, you'll want to use a configuration
manager to manage your themes and plugins.

::: panel-tabset
### MacOS

*Prezto* is my favorite configuration and plugin manager for zsh.
*OhMyZsh* is also popular and very good. Feel free to choose either --
but you can only use one.

Once you've installed Prezto, you've got (at least) three different
places you could configure your command line -- iTerm2 preferences,
`.zshrc`, and `.zpreztorc`. I'd recommend leaving `.zshrc` alone,
customizing the look of the window and the tab behavior in the iTerm2
preferences, and customizing the text theme and plugins via prezto in
the `.zpreztorc` file.

I tend to be a pretty light on customization, but I'd recommend looking
into git plugins and some of the advanced auto-completion and command
history search functionality.

### Windows

Many people like customizing PowerShell with [*Oh My
Posh*](https://ohmyposh.dev/).
:::

## Text Editors

If you're working on your command line a lot, you'll probably be working
inside *text editors* a fair bit. There are many, many options for text
editors and people have strong preferences.

Mac OS's default text editor is called TextEdit and it's bad. Don't use
it. Windows users get Notepad, which is somewhat better than TextEdit,
but still not the best option out there.

If you like, you can just edit text files inside your IDE of choice like
VS Code or RStudio. Others may prefer a standalone text editor. The most
popular these days are probably *Sublime* or *Notepad++* (Windows Only).

Unlike with the terminal, there's no deep configuration here. Install
one from the web, configure it as you like, and make sure it's the
default for opening `.txt` and other files you might want to edit in
your system preferences.

## Secure server connections with SSH

One common IT/Admin task is remotely managing a server from the command
line on your machine. SSH -- short for Secure (Socket) Shell -- is the
program that allows direct interactions with a server's command line
from the command line of your computer.[^2-2-cmd-line-2]

[^2-2-cmd-line-2]: SSH actually can be used between any two machines,
    provided at least one is accepting SSH connections. For data
    scientists, SSH is almost always use to connect from a local machine
    to a server.

Using SSH requires invoking the `ssh` command line interface with a
username and the address of the *remote host* [(]{.underline}server).
For example, to connect to the user `alex` on the remote host
`server.example.com`, it would look like:

``` {.bash filename="Terminal"}
> ssh alex@server.example.com
```

SSH opens a session between the local machine and the remote host via
the exchange of *SSH keys*.

SSH keys come in a set called *keypair*. Each keypair consists of a
*public* key and a *private* key. While it seems a little strange, the
public key can be shared far and wide, while the private key must be
treated as a precious secret.

This seems weird. Personally, until I had a basic understanding of how
SSH worked, I managed by just following online tutorials, but it always
felt like a guessing game where an incorrect guess would result in
compromising my server. That's why I'm going to spend a little time
explaining how SSH works.

When you run an SSH command, the local machine sends off a request to
open an SSH session to the remote and includes the private key with the
request.

The remote host would then use the corresponding public key, which has
already been registered, to verify the private key and open an encrypted
connection.

![](images/ssh.png){fig-alt="A diagram of SSH initialization. The local host sends the private key, the remote checks against the public key, and then opens the session."
width="450"}

Honestly, I wish public and private keys were named differently. Using
the term key for both makes them seem similar, but they're not.

If you have a public key and you're given a private key, it's easy to
check whether this is the right private key for the public key you've
got. But if you only have a public key, it's nearly impossible to
fabricate the private key that goes with it.

I think that calling the private key the *key* and the public key the
*lock* makes the intent much clearer. But no one asked me.

This asymmetry between the public and private keys is possible through
the magic of *public key cryptography*, which uses mathematical
operations that are easy in one direction but really hard to reverse.

As a simple example, think of the number $91$ and its prime factors. Do
you know what the prime factors of $91$ are offhand? I do not. It'll
probably take you a few minutes to try a bunch, even if you use a
calculator.

But if I give you the numbers $7$ and $13$, it's easy to verify that
$7 * 13 = 91$.

In this example, the number $91$ would be the public key and the prime
numbers $7$ and $13$ together would be the private key. This wouldn't
actually make for very good public key cryptography because it doesn't
take more than a few moments to figure out that $7$ and $13$ are prime
factors of $91$.

In real public key cryptography, the idea is similar, but the
mathematical operations are more complex and the numbers much, much
bigger.[^2-2-cmd-line-3] So much so that it's basically impossible to
break public ssh keys. Someone could try, but brute-force guessing would
take more time than we have left before the heat death of the universe.

[^2-2-cmd-line-3]: And prime numbers generally loom large in the
    operation.

That means that it's safe to share your public key anywhere you might
need to access using SSH like a remote server or git host, like GitHub.

But that doesn't make SSH foolproof. While it's basically impossible to
fabricate a private key, it's totally possible to steal one.

Your private key **must** be kept secret. The best practice is to never
move it from the computer where it was created and to never share them.

In summary, do what you want with your public keys, but don't share your
private keys. Don't share your private keys. Seriously, do not share
your private keys.

## Practical SSH usage

Now that you've got an understanding of how SSH works, the steps should
be easy to remember.

1.  Create an SSH keypair on any machine you'll be SSH-ing from (local
    host).
2.  Put the public key anywhere you'll be SSH-ing to (remote host).
3.  Use the `ssh` command to connect.

### Step 1: Create Keypair

You'll create a keypair on any server you're SSH-ing **from**.

To create an SSH keypair, you should just follow a tutorial online.
There are many. The keypair will have two parts. The one that ends in
`.pub` is -- you guessed it -- the public key.

In most cases, you'll only create one private key on each machine. If
you follow standard instructions for creating a key, it will use the
default name, probably `id_ed25519`.[^2-2-cmd-line-4] If you're only
creating one key, I'd recommend sticking with the default name because
the `ssh` command will automatically use your keys if they have the
default name.

[^2-2-cmd-line-4]: The pattern is `id_<encryption type>`. `ed25519` is
    the standard SSH key encryption type as of this writing.

::: callout-note
Remember, you should never move your private key. If you think the
answer to a problem you're having is to move your private key, think
again.

Instead of moving your private key, create a new private key from the
machine where you need to use SSH and register a second public key on
the remote.
:::

Some organizations require that you have a unique key for each service
you're using to make it easier to swap keys in the event of a breach. If
so, you won't be able to use the default key names.

### Step 2: Register the public keys

To register a public key on a server you control, you'll add the public
key to the end of the user's `.ssh/authorized_keys` file in their home
directory. You'll have to make sure the permissions on the
`authorized_keys` file are correct. More on that in [Chapter
@sec-linux].

If you're registering with a service, like GitHub.com, find a guide to
registering SSH keys and it will show you how to do so.

### Step 3: Use SSH

To use SSH, you type `ssh <user>@<host>`. There are also other commands
that can use SSH under the hood, like `git` or `scp`.

::: callout-note
## For Windows users

For a long time, Windows didn't support SSH out of the box, so SSH-ing
from Windows required a separate utility called *PuTTY*. More recent
versions of Windows support using SSH directly in PowerShell or in
Windows Subsystem for Linux (WSL). If SSH isn't enabled on your machine,
Google for instructions.
:::

If you have multiple SSH keys or didn't use the default flag, you can
specify a particular key with the `-i` flag.

If you're using SSH a lot, I'd recommend setting up an *SSH config
file*. An SSH config file allows you to create aliases that are
shortcuts to SSH commands including users, hosts, and other details. So
if you had a long SSH command like
`ssh -i my-ssh-key alex@server.example.com`, you could shorten it to
`ssh alex-server` or whatever you want.

Many people also like using *tmux* with SSH. SSH sessions block the
terminal session they're using and will break when your computer goes to
sleep. tmux is a terminal multiplexer, which allows you to manipulate
terminal sessions from the command line, including making sessions
durable through sleeps and other operations. To be honest, I'm including
tmux because lots of people love it, but I've tried using it and found
the learning curve too steep for it to come into regular usage. Your
mileage may vary.

Lastly, if you ever run into trouble using SSH, it has one of my
favorite debugging modes. Just add a `-v` to your command for verbose
mode. If that's not enough information, add another `v` for more
verbosity, and if **that's** not enough, just add another `v` for super
verbose mode.

## Comprehension Questions

1.  Draw a mental map that includes the following: terminal, shell,
    theme manager, operating system, my laptop
2.  Under what circumstances should you move or share your SSH private
    key?
3.  What is it about SSH public keys that makes them safe to share?

### Lab: Login to the server

### Step 1: Grab the server address

From the EC2 page, you can click on the instance ID in blue to see all
the details of about your server.

Copy the Public IPv4 DNS address, which starts with $\text{ec2-}$ and
ends with $\text{amazonaws.com}$. That little icon on the left of the
address copies it. You'll need it throughout the labs. If you lose it,
come back here to get it.

::: callout-tip
### Set a Server Address Variable

In the rest of the labs in this book, I'm going to write the commands
using the bash variable `SERVER_ADDRESS`. That means that if you create
that variable, you'll be able to just copy the commands out of the book.

For example, as I write this, my server has the address
$\text{ec2-54-159-134-39.compute-1.amazonaws.com}$. So would set my
server address variable on my command line with
`SERVER_ADDRESS=ec2-54-159-134-39.compute-1.amazonaws.com`.

If you're used to R or Python, where it's best practice to put spaces
around `=`, notice that assigning variables in bash *requires* no spaces
around `=`.
:::

### Step 2: Log on with the `.pem` key

The `.pem` key you downloaded when you set up the server is the private
key for a pre-registered keypair that will let you SSH into your server
as the admin user (named `ubuntu` on a Ubuntu system).

The `.pem` key is just an SSH key, so you can SSH to your server with

``` {.bash filename="Terminal"}
ssh -i do4ds-lab-key.pem \
  ubuntu@SERVER_ADDRESS
```

When you first try this, you're probably going to get an alert that
looks something like this:

``` bash

\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@

\@ WARNING: UNPROTECTED PRIVATE KEY FILE! \@

\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@

Permissions 0644 for 'do4ds-lab-key.pem' are too open.

It is required that your private key files are NOT accessible by others.

This private key will be ignored.

Load key "do4ds-lab-key.pem": bad permissions

ubuntu@ec2-54-159-134-39.compute-1.amazonaws.com: Permission denied (publickey).
```

Because the keypair is so powerful, AWS requires that you restrict the
access pretty severely. Before you can use it to open the server, you'll
need to change the permissions. We'll get into permissions in [Chapter
@sec-linux]. Until then, you can just change the permissions by
navigating to the right directory with the `cd` command and running
`chmod 600 do4ds-lab-key.pem`.

Once you've done that, you should be able to login to your machine as
the root user.

### Step 3: Create your own SSH key

You really shouldn't use the AWS-provided `.pem` key to login to your
server after the first time. It's too powerful. Create a normal SSH key
using the instructions earlier in this chapter. In the next lab, we'll
get that SSH key configured for your user on the server.

